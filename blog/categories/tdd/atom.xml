<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: TDD | derjan]]></title>
  <link href="http://derjan.io/blog/categories/tdd/atom.xml" rel="self"/>
  <link href="http://derjan.io/"/>
  <updated>2013-01-08T08:36:10+01:00</updated>
  <id>http://derjan.io/</id>
  <author>
    <name><![CDATA[Jan Ehrhardt]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[We do not trust our unit tests]]></title>
    <link href="http://derjan.io/blog/2012/10/16/we-do-not-trust-our-unit-tests/"/>
    <updated>2012-10-16T07:33:00+02:00</updated>
    <id>http://derjan.io/blog/2012/10/16/we-do-not-trust-our-unit-tests</id>
    <content type="html"><![CDATA[<p>There is a simple rule, why we write unit test or better why we
should. Unit tests give us the required trust to refactor our
code. Changing code is the reason, why we test it. But many developers
do not trust their unit tests. They expect a wrong kind of trust, that
unit test can not supply. Time to change how we think about quality
and changing code.</p>

<!--more-->


<h2>The missing trust in units</h2>

<p>The trust developers want is a large one. They want to trust their
application as a whole.  They want to know changing a line of code
breaks the application. There is a good reason for this. If you write
a method in a class that is used in many places everywhere in your
code and you change a line in this method, you can break many parts in
your software.</p>

<p>The solution is to do tests on the highest reasonable level. In the
best case this level is the UI of your software. But UI tests are also
the slowest solution. They require a lot of things. You should run
them on all supported platforms or browsers. You should run them with
a real database and all these other services, that will be involved in
your production environment. All these things must be done for just
changing one line of code. You only trust in this probably simple
change, when the whole application is set up and its UI still does
what it should.</p>

<p>As you might guess there is a better solution. Unit tests should run
very fast.  You should run them as part of your development process
many times in a hour. But they simply test a simple method or class.
How can we trust them? How can we prove the application will not be
broken by changing code?</p>

<h2>Write testable code</h2>

<p>Many people try to tell us
<a href="/blog/2012/08/31/dont-miss-to-write-good-unit-tests/">TDD</a> results in
testable code. But this is not true.  You first need to understand
what testable code really is. Testable code is written in a way, that
allows you to trust your unit tests. This includes testable code is
easy to test, but it means a lot more. Testable code is build of small
units with a well defined API. The API is defined by the unit tests
and the tests prove, the API works as expected.</p>

<p>A simple example. You have got a method, that is used all over your
code. It is invoked in hundreds of places. This might be good
sign. Your code is highly reusable. But having such a method means,
its API is used very frequently and changing the API has a big
potential to break your application. If you need to change this
method, try to keep its API stable. If you have good unit tests, you
can easily prove the stability.</p>

<p>A simple step to get code more testable is writting small classes
doing just a few things. Small classes are easier to test, but it is
also easier to keep there APIs stable. If classes have few
dependencies and small classes tend to have few dependencies, there
might be less potential side effects from other objects at
runtime. This will help you to make classes' APIs more stable.</p>

<p>If you write testable code, your code will become a big bunch of small
pieces each with a very stable API. If you make a change to your code,
it might affect just few places and hopefully it does not break your
internal APIs.</p>

<h2>What about the need of API breaks?</h2>

<p>Stable APIs are a good idea and you should pursue them. But sometimes
breaks are unavoidable. How can we deal with them?</p>

<p>A breaking API affects the users of the API. If your API breaks and
thus your existing tests have been changed, you need to work on the
users of the class or method too. Check their unit tests and write new
tests, if required to prove the API changes in the changed class do
not break their API. If their API also has been broken, go on and work
on their users too. Do this until you reach the point, where an API
keeps stable.</p>

<p>Testable code helps to deal with this. Breaking a classes API in a
testable code base does not affect the whole code. Instead it affects
just few classes or methods. If an API break also breaks the APIs of
the code's users, the code base is not testable.</p>

<h2>Improve quality</h2>

<p>We have seen, what kind of trust unit tests can supply to us. Although
this trust does not work very well, when your code is not testable
improving your code's quality writing testable code is a much better
way than doing all tests through the UI and let your code rot.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Applying the test automation pyramid to the real world]]></title>
    <link href="http://derjan.io/blog/2012/09/11/applying-the-test-automation-pyramid-to-the-real-world/"/>
    <updated>2012-09-11T07:47:00+02:00</updated>
    <id>http://derjan.io/blog/2012/09/11/applying-the-test-automation-pyramid-to-the-real-world</id>
    <content type="html"><![CDATA[<p><img class="right" src="/media/test-pyramid-fowler.png" width="373" height="540" title="Test Pyramid by Martin Fowler" alt="Test Pyramid by Martin Fowler"></p>

<p>You probaply heard of the test automation pyramid, which is a great
idea to make automated testing work in an agile development
environment. The image copied from <a href="https://twitter.com/martinfowler">Martin Fowler</a> shows it. He has also
<a href="http://martinfowler.com/bliki/TestPyramid.html">explains the pyramid</a>
pretty well.</p>

<p>The pyramid has three layers UI, Service and Unit tests. Theses layers
map well to standard web applications.  But in more complex systems
this simple model does not fit exactly at first view. But that is not
true. It fits perfectly, if you understand it right.</p>

<!--more-->


<h2>What is wrong with the real world?</h2>

<p>The test automation pyramid is created with web applications in
mind. Think of a simple monolithic LAMP or Rails application. All the
code is on the same server. In this case the idea of the pyramid fits
perfectly, since we have an UI and a monolithic application.</p>

<p>In the real world, the situation differs a lot. Many applications do
not have an UI at all. They might be so called backend services, which
provide some logic, that works somewhere in the backround. The UI part
of the software system is is probably written in a language like
<a href="http://www.ruby-lang.org">Ruby</a>, while the backend services - maybe
written in <a href="http://openjdk.java.net">Java</a>,
<a href="http://www.scala-lang.org">Scala</a> or <a href="http://clojure.org">Clojure</a> -
are accessed through HTTP. But how do you apply the pyramid?</p>

<h2>What is wrong with the pyramid?</h2>

<p>The problem comes from the miss leading names of the layers in the
pyramid. E. g. the top layer is called UI tests and our backend
application has no UI. Sure there is hopefully an UI application, that
access our backend service and has UI tests, but is that enough?</p>

<p>The solution is a simple renaming of the layers. Let us call the top
layer <em>function tests</em> instead of UI tests. This name also applies well
to non GUI applications. The tests in this layer should be very
similar to UI tests.</p>

<h2>Testing an application works</h2>

<p>The <em>functional test</em> layer on top should prove the application
works. This means, you have at least to start your application
and access it through some mechanism similar to your production
environment. In the best case your application will be deployed to a
real server with a real database. Everything like authentication or
access over the network should happen in a function test the same way
it does in a production environment.</p>

<p>While the infrastructural requirements for theses tests are high and
the tests itself might run very slow, there should be only few test
cases in this category. You should not test failures here or some edge
cases. Simply make sure your application is deployed, can access the
database and answers as expected to some requests.</p>

<p>This kind of definition works for backend applications as well as for
UI applications. UI tests are just a special form of functional
tests. If you have both an UI application with UI tests and a backend
service, your UI tests should run end to end, which also includes your
backend services. In addition your backend service can also have its
own functional tests, doing some basic HTTP requests. So you end up
with functional tests on different layers of your system.</p>

<p>An important point is to know, that developers might not run theses
test very frequently on their own local machines. But this is ok as
long as some continous integration server will run them regularly.</p>

<h2>Testing your application behaves correctly</h2>

<p>When <em>functional tests</em> do not test the correct behaviour of your
application, you need another layer to this. In the test pyramid the
<em>service test</em> layer does this job.</p>

<p>Different to functional tests developers should run service tests very
frequently. Thus the tests must execute fast enough to do
this. Starting a Java EE application server might be much to slow for
this. So service tests should skip this. Instead they should be
written similar to unit tests, using a tool like Junit and
instantiating objects from your code.</p>

<p>But what should be tested exactly? A good service test runs a
typical scenario, that might appear similar in production. So take a
typical conversation with your application and write it down in your
test case. You should make sure, you focus on positive tests and skip
error handling and edge cases at this level.</p>

<p>Service tests should make sure, the parts of your code work together
as expected and behave like they should. This includes integration
with third party libraries and even persistence. But always keep it
simple. Use a simple database like <a href="http://www.sqlite.org">SQLite</a> or
<a href="http://www.h2database.com">H2</a> instead of a full blown database
server. Use simple HTTP mocks with static JSON files instead of real
services in the backend. Keep your infrastructure as lean as possible
to make running the tests easy.</p>

<h2>Testing your code</h2>

<p>A <em>unit test</em> should be executable as fast as possible. If some
framework needs some seconds to initialize, skip it in the unit
tests. Make your tests as fast as possible. There is a simple reason
for this performance requirement. Developers should not run unit tests
just frequently, they should run them as often as possible. You
changed a line of code? Run the tests! This is how it should work and
thus performance matters a lot.</p>

<p>Since unit tests should be very fast, it is cheap to run them, but it
is also cheap to test edge cases and failure handling in unit
tests. If your application should be able to deal with null values,
unit tests are the place to prove it. If your application should
validate some data, unit tests are the place to prove it. If your
application should apply an algorithm, unit tests are the place to
prove it.</p>

<p>Unit tests can do
<a href="/blog/2012/08/31/dont-miss-to-write-good-unit-tests/">much more</a>. They
can help other developers to understand your code and its behaviour
better. They can help you to change your code, without fearing to
break it. And they can help you to find errors in the code, when they
fail.</p>

<h2>When should your tests run?</h2>

<p>Unit tests can be found near the production code. In multi module
projects, each module will have its unit tests. Most tools like Maven
or Gradle in the Java world or Rake in the Ruby world will run the
unit test by default, so there should be no probem for your continous
integration server. Java IDEs have also integration for common test
frameworks.</p>

<p>Little harder is to run service tests. They might be much slower than
unit tests, so there should not be so much test cases to
run. Important is, that a standard build like <em>gradle build</em> or <em>mvn
clean package</em> will run theses tests. After all modules have been
compiled, all unit tests should be executed. Now it is time to run the
integration tests. They prove, the standard interaction with your
software works well. Integration tests can be placed in a separate
module to make this work best. But at least keep them separated from
your unit tests to reduce problems.</p>

<p>The hardest part are the functional tests. Since their primary goal is
to prove, the software runs and works as expected, there is no reason
to execute them all the time as part of the standard build. Instead
you should make theses tests easily executable without building the
whole software. It is great, when a continous integration server
deploys the software on a test machine with a real database, real HTTP
and real authentication and than runs the functional tests against
this system.</p>

<h2>Other ways</h2>

<p>Sure this is one solution to the problem and you may have found
another way to work with different test levels. What do you think?
How did you solve this? What worked great? What was bad? Leave me a
comment.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Don't miss to write good unit tests]]></title>
    <link href="http://derjan.io/blog/2012/08/31/dont-miss-to-write-good-unit-tests/"/>
    <updated>2012-08-31T10:46:00+02:00</updated>
    <id>http://derjan.io/blog/2012/08/31/dont-miss-to-write-good-unit-tests</id>
    <content type="html"><![CDATA[<p>It is not enough for today's software developers to know their
programming language well. There are further skills, that more and
more companies are expecting from there employees. One of the most
important is
<a href="https://en.wikipedia.org/wiki/Test-driven_development">Test Driven Development</a>
(TDD). This is not an introduction to TDD. If you want to learn it, I
recommend <a href="https://twitter.com/unclebobmartin">Uncle Bob's</a> awesome
<a href="http://www.cleancoders.com/">Clean Code Videos</a> (Episode 6 - TDD) or
simply <a href="https://www.google.com/search?q=tdd+tutorial">ask Google</a> for
it. But many developers are writing bad code and applying TDD does not
make them writing good code. Instead it makes them also writing bad
tests. So this is about writing better test code.</p>

<!--more-->


<h2>Applying simple rules</h2>

<p>To understand why test code can be bad, you should understand, what it
should do. It should work as the parachute, that keeps you alive, when
refactoring your code. Tests may help you to be sure nothing breaks,
when adding new features to your code. But tests may also work as
sample code, that documents your APIs better than any other
documentaion except the code itself.</p>

<p>But how can you make your tests better? It might help to follow some
simple rules, that could be easily applied to every language or test
style like BDD or Junit-style.</p>

<h2>Tests should be a state machine</h2>

<p>Many people do not like BDD at all, but there is a pretty nice idea in
it - the given-when-then style some frameworks promote. This style
forces you into a way of thinking about tests, that you should adapt.
Even if you do not use a BDD framework.</p>

<p>Writing a test this way means there is a start state, something
happens and than an end state is reached. If your test is broken, the
state machine in it is broken. In BDD frameworks the first part of
your test is the <em>given</em> block, where all the setup stuff is done. The
second part is the <em>when</em> block, where an action is applied on the
test object, created in the given block. At least you have a <em>then</em>
block, where you assert, that the correct end state is reached.</p>

<p>It is very helpful to have this in mind while writing a new test. Keep
these three parts seperated and do not mix them in some way. Do not
write code in your test, where an <em>if</em> appears, or even more complex
logic. In a test you should only do the above three steps. Do some
simple setup, call a method on your test object or invoke the test
function and assert the result is correct.</p>

<p>This might also make your code better. If you write messy code, tests
written this way are harder to create and maintain. If you have to
much of inheritance, dependencies on other objects or resources like
IO, you will have to set it up in every test you write and that is no
fun. But you should write your tests first and hopefully it makes
writing messy code harder, if you have written a well structured tests
first.</p>

<h2>Tests should be good examples for using your API</h2>

<p>Every code you write has an API. If your application has a graphical
user interface or it is an open source library, there is some way it
is used by others. If some other developer is changing your code, or
working with you in the same team, there is an API for each class or
function in the whole code. You can write documentation like JavaDoc
on every public method, but this tends to be out of date, since many
developers miss to update it when they change the code.</p>

<p>A better way of technical documentation for source code are code
snippets, that show how to use a class or function. But many
developers do not have this in mind, while writing tests. That is sad,
because tests use your code and should be executed frequently. So they
are already working code samples.</p>

<p>Before you write a test, you should first think about how someone
wants to use your code. How should your methods be named? What
parameters do users want to pass to it? What do they expect as a
result? The next step might be writing a test, that simply shows, how
a user would call your code. Does it look well? Is it simple or
complex? Could it even look simpler? Once your test defines the API,
write the code to make it green.</p>

<p>If you have done your job well, someone looks to your tests and
understands how to use your code. This documentation does not outdate
as long as all tests are executed frequently. If it outdates, it will
hopefully break your build.</p>

<h2>Tests should have meaningful assertions</h2>

<p>Do you write debug logging statements in your code? Why are you doing
it?</p>

<p>Most developers want to know, why their code fails and this is, where
debug logging comes in. If you write good tests for your code, you
should know, that your code behaves as it should, because it is
verified by the tests. So there is no need for debug logging
anymore. But what happens, if you change some code and break some
other code by this change? In the best case some test will fail, but
you do not know why.</p>

<p>This is where assertion come in. You should spend some time in
learning how assertions in your test framework realy work. You should
figure out, if there are open source libraries, that could improve
assertions in your tests, like
<a href="https://github.com/alexruiz/fest-assert-2.x/wiki">fest</a> does in the
Junit or <a href="http://spockframework.org">Spock</a> does for Java at all.</p>

<p>The most important work assertions should do is telling you why a test
has failed. In the best case it prints the expected value and the
actual value and shows you how they differ. This might help you to
figure out, what is wrong with your code. And might do this much
better than any debug logging.</p>

<h2>Reaching the next level of TDD</h2>

<p>As you can see, it is not enough to learn how to do TDD. You should
also learn how to write good tests. The above rules are not simple to
apply, but might improve your test code's quality. At all they may
help you reaching the next level of TDD and the next level of writing
source code. You should start to apply them as soon as possible to
make your test code much cleaner.</p>

<p>There are a lot more good techniques to improve TDD. Tell me about
them in the comments.</p>
]]></content>
  </entry>
  
</feed>
