<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[derjan]]></title>
  <link href="http://derjan.io/atom.xml" rel="self"/>
  <link href="http://derjan.io/"/>
  <updated>2012-08-27T12:44:00+02:00</updated>
  <id>http://derjan.io/</id>
  <author>
    <name><![CDATA[Jan Ehrhardt]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Be fair to Scala, do not expect a better Java]]></title>
    <link href="http://derjan.io/blog/2012/08/27/be-fair-to-scala/"/>
    <updated>2012-08-27T12:43:00+02:00</updated>
    <id>http://derjan.io/blog/2012/08/27/be-fair-to-scala</id>
    <content type="html"><![CDATA[<p>To some Java developers Scala has become an alternative to Java as a
programming language. So they started learning it and do the first
steps in writing some Scala code. To most of them the next step might
be the first contact with a Scala library and hopefully a Scala test
framework. But right after the first contact, I here them
screaming. Oh my god, this library uses all the tricky features Scala
comes with. Do the developers not care about readability?</p>

<!--more-->


<h2>Some lines of Scala code</h2>

<p>What is the problem in Scala? To understand it, lets take a brief look
to some Scala code.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">object</span> <span class="nc">Application</span> <span class="k">extends</span> <span class="nc">App</span> <span class="k">with</span> <span class="nc">PathConversion</span> <span class="k">with</span> <span class="nc">StringConversion</span> <span class="o">{</span>
</span><span class='line'>  <span class="nc">Files</span><span class="o">.</span><span class="n">write</span><span class="o">(</span><span class="s">&quot;log&quot;</span><span class="o">,</span> <span class="s">&quot;Hello world\n&quot;</span><span class="o">,</span> <span class="nc">APPEND</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This code appends a line to a file. It uses the
<a href="http://docs.oracle.com/javase/7/docs/api/java/nio/file/package-summary.html">new file API</a>
introduced in Java 7 to do this.</p>

<p>The
<a href="http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#write(java.nio.file.Path,%0Abyte[],%20java.nio.file.OpenOption...)">write</a> method only accepts a
<a href="http://docs.oracle.com/javase/7/docs/api/java/nio/file/Path.html">Path</a>
object and a byte[] as parameters. The trick is done in the traits
<em>StringConversion</em> and <em>PathConversion</em>, which provide implicit
methods to convert Strings.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">StringConversion</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">implicit</span> <span class="k">def</span> <span class="n">bytes</span><span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">text</span><span class="o">.</span><span class="n">getBytes</span><span class="o">(</span><span class="nc">Charsets</span><span class="o">.</span><span class="nc">UTF_8</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">trait</span> <span class="nc">PathConversion</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">implicit</span> <span class="k">def</span> <span class="n">stringAsPath</span><span class="o">(</span><span class="n">path</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">path</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The methods in the traits are called implicit, thus the compiler will
create byte code, that calls these methods. But these calls are not
written expilcitly in the code.</p>

<h2>What Java developers do not like</h2>

<p>The above code snippets are using a nice features, that Scala provides
and that Java does not. But when Java developers start using Scala,
they often look at it as a better Java and thus they expect to use
their existing skills.</p>

<p>One problem are the implicit calls to methods. In the Java world
static typing is not just used for type checking at compile time. It
is also used as an implicit type documentation. So a Java developer
would look at the signature of the write method and see that it only
accepts objects of type Path and byte[] as parameters. But a look to
the method call shows, that Strings are passed to it.</p>

<p>From a Java developer&#8217;s point of view, this is not easy to understand.
Where is this implicit conversion of types done? A Java developer
might think, this reduces readability. But this is not true.</p>

<h2>It is not Scala&#8217;s fault</h2>

<p>Scala is not a better Java. It is a completely different language. As
any other language too, Scala also has a community around it. There
are libraries and APIs designed for Scala and they are using the
features of the language. This is exactly how it should be.</p>

<p>The way a developer works with Java is not the way a developer works
with Ruby or Python or even JavaScript. Many Ruby developers use a
text editor instead of a fat IDE, while Java without any IDE is really
painful. Using the declared types of method parameters to figure out,
what you can pass into this method is also a Java way of working. In
Ruby, Python or JavaScript, there are no declared types. There is even
no type checking at compile time. But people know how to use methods
and classes in these languages as well.</p>

<p>Scala&#8217;s type system is very powerful, while Java&#8217;s is not. It allows
you to do things like the above and it is good, when Scala developers
are using these features in their code and APIs. But the power of
Scala&#8217;s type system makes it also complex. The compiler can check the
types, while the developer may not understand them easily from the
method signature.</p>

<h2>Learn to work the Scala way</h2>

<p>There is only one solution to this problem. Java developers must learn
how to work with a language, that has a type system different from
Java&#8217;s. They have to change their mind and extend their skills.</p>

<p>Well, if you do not get comfortable with this, Scala is not your
language. Take your hands off and go home to your Java code.</p>

<p>What do you think? How do you solve the parameter documentation in
your favorite programming language? And how do you figure out how to
use a method?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First steps with Groovy's invokedynamic support]]></title>
    <link href="http://derjan.io/blog/2012/08/08/first-steps-with-groovys-invokedynamic-support/"/>
    <updated>2012-08-08T07:29:00+02:00</updated>
    <id>http://derjan.io/blog/2012/08/08/first-steps-with-groovys-invokedynamic-support</id>
    <content type="html"><![CDATA[<p>It is not really new, but
<a href="http://docs.codehaus.org/display/GROOVY/2012/06/28/Groovy+2.0+released">Groovy 2.0 is out</a>.
There is even a version
<a href="http://docs.codehaus.org/display/GROOVY/2012/06/28/Groovy+2.0+released">2.0.1 released</a>,
which only fixes some bugs. One of the new features introduced with
version 2.0 is support for invokedynamic. But it is not used by
default, instead you have to activate it. But there is only few
documentation and it is spread over the web. So how do we use
invokedynamic in our code?</p>

<!--more-->


<h2>Get your machine ready</h2>

<p>First of all you should have installed
<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Java 7</a>,
since invokedynamic is not available in earlier versions of Java. The
easiest way to test invokedynamic support is by using the command
line, so should also have installed
<a href="http://groovy.codehaus.org/Download">Groovy 2.0</a> or later.</p>

<p>Having Groovy installed you could simply use it with the <em>groovy</em>
command in your terminal, but a different way, you should be familiar
with is to compile Groovy code with <em>groovyc</em> to Java byte code. The
byte code can be executed with <em>java -classpath</em>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>wget -O HelloWorld.groovy https://raw.github.com/gist/3292829/f9d2a37c6cdc45570aab1bf0ce665262899a0dde/HelloWorld.java
</span><span class='line'>groovyc HelloWorld.groovy
</span><span class='line'>java -classpath .:<span class="nv">$GROOVY_HOME</span>/embeddable/groovy-all-2.0.1.jar HelloWorld
</span></code></pre></td></tr></table></div></figure>


<p>These steps are pretty similar to my
<a href="https://gist.github.com/3292829">first steps with Java</a> years ago and
they are necessary to do your first steps with invokedynamic. But at
this time there is no invokedynamic involved.</p>

<h2>Two steps to use invokedynamic</h2>

<p>The first step on our way to invokedynamic is using the right Groovy
JAR, while executing our byte code. In <em>$GROOVY_HOME/embeddable/</em> you
can find <em>groovy-all-2.0.1-indy.jar</em>, where indy is short for
invokedynamic. This JAR contains a version of Groovy, that uses
invokedynamic instead of Groovy&#8217;s very own old dynamic invoking code.</p>

<p>Using the indy JAR is not enough, since everything should still work
under Java 5 or 6, even this JAR is used. The byte code created by
Groovy compiler is not using any Java 7 features. So the second step
is to tell the <em>groovyc</em> command to compile our Groovy code using
invokedynamic by adding the <em>&#8211;indy</em> flag. The above sample should now
look like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>wget -O HelloWorld.groovy https://raw.github.com/gist/3292829/f9d2a37c6cdc45570aab1bf0ce665262899a0dde/HelloWorld.java
</span><span class='line'>groovyc --indy HelloWorld.groovy
</span><span class='line'>java -classpath .:<span class="nv">$GROOVY_HOME</span>/embeddable/groovy-all-2.0.1-indy.jar HelloWorld
</span></code></pre></td></tr></table></div></figure>


<h2>Make your Groovy 2.0 indy</h2>

<p>Running the above code will fail at second command with a curious
exception:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>groovy.lang.GroovyRuntimeException: Cannot use invokedynamic, indy module was excluded from this build.
</span></code></pre></td></tr></table></div></figure>


<p>What went wrong? Didn&#8217;t I use Groovy 2.0? Didn&#8217;t I pass the <em>&#8211;indy</em>
flag correctly? The
<a href="http://permalink.gmane.org/gmane.comp.lang.groovy.devel/26698">solution</a>
is simple, once you understand your Groovy installation. The Groovy
JARs used by <em>groovyc</em> are in <em>$GROOVY_HOME/lib/</em>, but the indy JARs
are in <em>$GROOVY_HOME/indy/</em>. So replace the Groovy JAR with the indy
version.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">cd</span> <span class="nv">$GROOVY_HOME</span>
</span><span class='line'>cp -R lib lib.org
</span><span class='line'>cp indy/groovy-2.0.1-indy.jar lib/groovy-2.0.1.jar
</span></code></pre></td></tr></table></div></figure>


<p>Now the above sample should work, but it really looks like the Groovy
developers do not want you to use invokedynamic. They made it as
difficult as possible, but why?</p>

<h2>Loosing previous optimizations with invokedynamic</h2>

<p>The Groovy developers have spent a lot of time to get Groovy&#8217;s runtime
faster. One great step was the primitive optimization introduced with
Groovy 1.8. But these optimizations are not available if everything is
delegated to the JVM, what happens with invokedynamic.</p>

<p>You can test it using a simple
<a href="https://gist.github.com/3293383">Fibonacci sample</a>. Running the
sample on my machine with <em>fibonacci(42)</em>, the result looks like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Java: 1.43s
</span><span class='line'>Groovy 1.8 or 2.0: 3.08s
</span><span class='line'>Groovy 2.0 with indy: 6.55s
</span></code></pre></td></tr></table></div></figure>


<h2>It&#8217;s just the first step for Groovy</h2>

<p>It is good for Groovy to support invokedynamic, but the support is not
ready yet. Some code might benefit from it, but other does
definitively not. The JVM currently does not support all optimizations
the Groovy runtime already does.</p>

<p>Making the usage of invokedynamic difficult hopefully prevents people
from using it without knowing about the impacts. So we&#8217;ll see, how
well Groovy and invokedynamic will work together in future versions.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring and JSR 330 scopes]]></title>
    <link href="http://derjan.io/blog/2011/10/18/spring-and-jsr-330-scopes/"/>
    <updated>2011-10-18T07:09:00+02:00</updated>
    <id>http://derjan.io/blog/2011/10/18/spring-and-jsr-330-scopes</id>
    <content type="html"><![CDATA[<p>Spring 3 added support for
<a href="http://download.oracle.com/javaee/6/api/javax/inject/package-summary.html">JSR 330 configuration</a>,
so you can use <strong>@Named</strong> and  <strong>@Inject</strong> instead of <strong>@Component</strong> and
<strong>@Autowired</strong>. Unfortunately Spring&#8217;s default scoping is not compatible with
JSR 330. Here is how it works:</p>

<!--more-->


<h2>Default behaviour</h2>

<p>By default Spring uses it&#8217;s default scoping behaviour on JSR 330 configured
beans like below.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Named</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GreetingService</span> <span class="o">{</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This means, that <em>GreetingService</em> will become a bean with singleton scope.</p>

<h2>JSR 330 scopes</h2>

<p>In difference to Spring JSR 330 defines, that the default scope of beans is
prototype, which means a new object is created everytime it will be injected
somewhere. If you want a different scoping you can create your own annotation for
this like descriped
<a href="http://download.oracle.com/javaee/6/api/javax/inject/Scope.html">here</a>. JSR 330
already comes with a predifined scope annotation for
<a href="http://download.oracle.com/javaee/6/api/javax/inject/Singleton.html">singletons</a>. To
make Spring behave as specified in JSR 330, you can use a different scope
resolver like below.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;context:component-scan</span> <span class="na">base-package=</span><span class="s">&quot;my.package&quot;</span>
</span><span class='line'>  <span class="na">scope-resolver=</span><span class="s">&quot;org.springframework.context.annotation.Jsr330ScopeMetadataResolver&quot;</span> <span class="nt">/&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Using this additional configuration, will make the above <em>GreetingService</em> bean
prototype scoped. To make it a singleton bean again, you will need to use the
singleton scope annotation.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Named</span>
</span><span class='line'><span class="nd">@Singleton</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GreetingService</span> <span class="o">{</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Custom scopes for JSR 330</h2>

<p>Spring comes with further scopes like <em>request</em> or <em>session</em>. JSR 330 does not
support them out of the box. You will have to create your own annotations for
this. Let&#8217;s look, how to do this for the <em>request</em> scope.</p>

<ol>
<li>Create your own scope annotation:</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Scope</span>
</span><span class='line'><span class="nd">@Documented</span>
</span><span class='line'><span class="nd">@Retention</span><span class="o">(</span><span class="n">RUNTIME</span><span class="o">)</span>
</span><span class='line'><span class="kd">public</span> <span class="nd">@interface</span> <span class="n">Request</span> <span class="o">{</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Extend <em>Jsr330ScopeMetadataResolver</em> to map your annotation on Spring&#8217;s
scope:</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CustomScopeMetadataResolver</span> <span class="kd">extends</span> <span class="n">Jsr330ScopeMetadataResolver</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="nf">Jsr330SpringScopeMetadataResolver</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">registerScope</span><span class="o">(</span><span class="n">Request</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">WebApplicationContext</span><span class="o">.</span><span class="na">SCOPE_REQUEST</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Use your custom resolver in your Spring configuration:</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;context:component-scan</span> <span class="na">base-package=</span><span class="s">&quot;my.package&quot;</span>
</span><span class='line'>  <span class="na">scope-resolver=</span><span class="s">&quot;my.resolver.package.CustomScopeMetadataResolver&quot;</span> <span class="nt">/&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>The above sample will make all beans, that are annotated with your own
<strong>@Request</strong> annotation request scoped.</p>
]]></content>
  </entry>
  
</feed>
